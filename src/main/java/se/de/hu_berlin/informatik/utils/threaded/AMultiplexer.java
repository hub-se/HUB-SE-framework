package se.de.hu_berlin.informatik.utils.threaded;

import java.util.concurrent.locks.LockSupport;

/**
 * Abstract multiplexer that collects output generated by multiple
 * threads and processes it.
 * 
 * @author Simon Heiden
 * @param <B>
 * the type of objects that are processed
 */
public abstract class AMultiplexer<B> implements IMultiplexer<B> {

	private IMultiplexerInput<B>[] handlers;
	
	private Thread thread = null;
	private boolean shouldStop;
	private boolean shouldDefinitivelyStop;
	
	private boolean isRunning = false;
	
	public AMultiplexer(IMultiplexerInput<B>[] handlers) {
		this();
		connectHandlers(handlers);
	}
	
	public AMultiplexer() {
		super();
	}
	
	/* (non-Javadoc)
	 * @see se.de.hu_berlin.informatik.utils.threaded.IMultiplexer#setHandlers(se.de.hu_berlin.informatik.utils.threaded.IMultiplexerInput[])
	 */
	@Override
	public void connectHandlers(IMultiplexerInput<B>[] handlers) {
		this.handlers = handlers;
	}

	/* (non-Javadoc)
	 * @see se.de.hu_berlin.informatik.utils.threaded.IMultiplexer#start()
	 */
	@Override
	public Thread start() {
		if (!isRunning) {
			thread = new Thread(this);
			thread.start();
			isRunning = true;
		}
		return thread;
	}
	
	@Override
	public void run() {
		shouldStop = false;
		shouldDefinitivelyStop = false;
		if (handlers == null || handlers.length == 0) {
			throw new IllegalStateException("No handlers given to multiplexer.");
		}
		//collect available output in an infinite loop
		while (true) {
			//wait until new output items are available
			waitForNotifications();
			//iterate over all input threads (all handlers)
			checkForPendingItems(handlers);
			//test if shutdown condition is fulfilled 
			if (shouldStop) {
				//test if we already checked for any pending outputs
				if (shouldDefinitivelyStop) {
					//then we may return now...
					return;
				}
				//there might still be pending output items, so better check...
				shouldDefinitivelyStop = true;
				initiateCheckForPendingItems();
			}
		}
	}

	/* (non-Javadoc)
	 * @see se.de.hu_berlin.informatik.utils.threaded.IMultiplexer#getThread()
	 */
	@Override
	public Thread getThread() {
		return thread;
	}

	/* (non-Javadoc)
	 * @see se.de.hu_berlin.informatik.utils.threaded.IMultiplexer#shutdown()
	 */
	@Override
	public void shutdown() {
		shouldStop = true;
		initiateCheckForPendingItems();
		while (thread.isAlive()) {
			try {
				thread.join();
			} catch (InterruptedException e) {
				// do nothing
			}
		}
		isRunning = false;
	}
	
	@Override
	public void initiateCheckForPendingItems() {
		LockSupport.unpark(thread);
	}

	@Override
	public void waitForNotifications() {
		LockSupport.park();
	}
	
}
